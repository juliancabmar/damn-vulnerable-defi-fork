---
eip: 191
title: Estï¿½ndar de Datos Firmados
author: Martin Holst Swende (@holiman), Nick Johnson <arachnid@notdot.net>
discussions-to: https://github.com/ethereum/EIPs/issues/191
status: Final
type: Standards Track
category: ERC
created: 2016-01-20
---

# Resumen

Este ERC propone una especificacion sobre como manejar datos firmados en contratos de Ethereum.

# Motivacion

Se han creado varias implementaciones de billeteras multifirma que aceptan transacciones `pre-firmadas`. Una transaccion `pre-firmada` es un bloque de datos binarios `signed_data`, junto con una firma (`r`, `s` y `v`). La interpretacion de `signed_data` no ha sido especificada, lo que ha conducido a varios problemas:

* Las transacciones estandar de Ethereum pueden ser enviadas como `signed_data`. Una transaccion de Ethereum puede descomponerse en los siguientes componentes: `RLP<nonce, gasPrice, startGas, to, value, data>` (de aqui en adelante llamado `RLPdata`), `r`, `s` y `v`. Si no hay restricciones sintacticas sobre `signed_data`, esto significa que `RLPdata` puede ser utilizado como una transaccion `pre-firmada` sintacticamente valida.
* Las billeteras multifirma tambien han tenido el problema de que una transaccion `pre-firmada` no ha estado ligada a un `validador` especifico, es decir, a una billetera en particular. Ejemplo:
    1. Los usuarios `A`, `B` y `C` tienen la billetera `X` con esquema `2/3`
    2. Los usuarios `A`, `B` y `D` tienen la billetera `Y` con esquema `2/3`
    3. Los usuarios `A` y `B` envian transacciones `pre-firmadas` a `X`.
    4. Un atacante ahora puede reutilizar esas transacciones pre-firmadas destinadas a `X`, y enviarlas a `Y`.

## Especificacion

Proponemos el siguiente formato para `signed_data`:

```
0x19 <1 byte de version> <datos especificos de la version> <datos a firmar>.
```

El byte inicial `0x19` esta destinado a asegurar que `signed_data` no sea un RLP valido.

> Para un solo byte cuyo valor este en el rango [0x00, 0x7f], ese byte es su propia codificacion RLP.

Esto significa que cualquier `signed_data` no puede ser una unica estructura RLP, sino una carga util de `RLP` de 1 byte seguida de otra cosa. Asi, cualquier `signed_data` bajo EIP-191 nunca podra ser una transaccion de Ethereum.

Ademas, se ha elegido `0x19` porque, desde ethereum/go-ethereum#2940, se antepone lo siguiente antes de hacer el hash en `personal_sign`:

```
"\x19Ethereum Signed Message:\n" + len(message).
```

Usar `0x19` permite extender el esquema definiendo una version `0x45` (`E`) para manejar este tipo de firmas.

### Registro de bytes de version

| Byte de version | EIP            | Descripcion
| ---------------- | -------------- | -----------
|    `0x00`         | [191][eip-191] | Datos con validador destinado
|    `0x01`         | [712][eip-712] | Datos estructurados
|    `0x45`         | [191][eip-191] | Mensajes de `personal_sign`

#### Version `0x00`

```
0x19 <0x00> <direccion del validador destinado> <datos a firmar>
```

La version `0x00` utiliza `<direccion del validador destinado>` como los datos especificos de la version. En el caso de una billetera multifirma que realiza una ejecucion basada en una firma pasada, la direccion del validador es la direccion de la propia billetera multifirma. Los datos a firmar pueden ser cualquier dato arbitrario.

#### Version `0x01`

La version `0x01` es para datos estructurados como se define en [EIP-712].

#### Version `0x45` (E)

```
0x19 <0x45 (E)> <"thereum Signed Message:\n" + len(message)> <datos a firmar>
```

La version `0x45` (E) utiliza `<"thereum Signed Message:\n" + len(message)>` como datos especificos de la version. Los datos a firmar pueden ser cualquier dato arbitrario.

> Nota: La `E` en `Ethereum Signed Message` se refiere al byte de version 0x45. El caracter `E` es `0x45` en hexadecimal, lo que hace que el resto, `"thereum Signed Message:\n" + len(message)`, sean los datos especificos de la version.

[EIP-191]: ./eip-191.md  
[EIP-712]: ./eip-712.md

### Ejemplo

Los siguientes fragmentos estan escritos en Solidity 0.8.0.

#### Version `0x00`

```solidity
function signatureBasedExecution(address target, uint256 nonce, bytes memory payload, uint8 v, bytes32 r, bytes32 s) public payable {
        
    // Argumentos al calcular el hash para validar
    // 1: byte(0x19) - el byte inicial 0x19
    // 2: byte(0) - el byte de version
    // 3: address(this) - la direccion del validador
    // 4-6: Datos especificos de la aplicacion

    bytes32 hash = keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), msg.value, nonce, payload));

    // Recuperar la direccion del firmante desde el hash y la firma
    addressRecovered = ecrecover(hash, v, r, s);
   
    // Logica de la billetera
    // if (addressRecovered == owner) executeOnTarget(target, payload);
}
```

Copyright

Derechos de autor y derechos relacionados renunciados via CC0.